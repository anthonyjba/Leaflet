<!DOCTYPE html>
<html>
<head>
	<title>Test CartoDB</title>
	<style type="text/css">

		body, canvas {
			background-color: 'rgba(255,255,255,0.1)';            
		}
        canvas {
            position:absolute;
            left:0px;
            top:0px;
            border: 1px solid black;
        }
        img{
            position:absolute;
            left:0px;
            top:0px;
        }
	</style>
</head>
<body>
    <img src="data_Cartodb/NY1280-13.png" />
    <canvas id="canvas1" width="1280" height="1280"></canvas>
	<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
 	<script type="text/javascript">
 		
 	(function($) {


		// parameters
		var width = 1280,
			height = 1280,
			//margin = 0,
			zoom = 13,
			panX = 0,
			panY = 0,
            
            //https://rambo-test.cartodb.com/api/v2/sql?q=select cartodb_id, st_envelope(the_geom) from public.mnmappluto
			//url = 'https://rambo-test.cartodb.com/api/v2/sql?q=select cartodb_id, st_asgeojson(the_geom) from public.mnmappluto'
            url = 'data_Cartodb/cartodb-query-all.json'
			;


		// private variables	
		var min = [10000, 10000],
			max = [-10000, -100000],
			geometries  = [],
			drawing = false,
			canvas,
			ctx,
			startCoords = [0, 0],
			last = [0,0],
			dragged = false,
			focus
			;

        var grid = document.getElementById('canvas1');
        var ctxg = grid.getContext('2d');
        ctxg.moveTo(width/2 +0.5, 0);
        ctxg.lineTo(width/2 + 0.5, height)
        ctxg.moveTo(0.5, height/2);
        ctxg.lineTo(width, height/2 + 0.5)
        ctxg.strokeStyle = 'rgba(0, 0, 0, 0.2);'
        ctxg.stroke();
        
		canvas = document.createElement('canvas');
		canvas.width = width;
		canvas.height = height;

		ctx = canvas.getContext('2d');

		document.body.appendChild(canvas);

		canvas.addEventListener('DOMMouseScroll',handleScroll,false);
		canvas.addEventListener('mousewheel',handleScroll,false);
		canvas.addEventListener('mousedown', handleMouseDown, false);
		canvas.addEventListener('mousemove', handleMouseMove, false);
		canvas.addEventListener('mouseup', handleMouseUp, false);

		render();
        
        function fromLatLngToPoint(latLng){
            var siny =  Math.min(Math.max(Math.sin(latLng[1]* (Math.PI / 180)),
                                   -.9999),
                          .9999);
            return [128 + latLng[0] * (256/360),
                    128 + 0.5 * Math.log((1 + siny) / (1 - siny)) * -(256 / (2 * Math.PI))];
        }
        
        function fromPointToLatLng(point){
            return {
            lat: (2 * Math.atan(Math.exp((point.y - 128) / -(256 / (2 * Math.PI)))) -
                    Math.PI / 2)/ (Math.PI / 180),
            lng:  (point.x - 128) / (256 / 360)
            };
        }

		function extractGeometries(geojsons) {
			var geojson, coords, coord, point, points, i, j, l, ll;
			
			for (i = 0, l = geojsons.length; i < l; i++) {
				geojson = geojsons[i];
				coords = geojson.coordinates[0][0];

				points = [];

				for (j = 0, ll = coords.length; j < ll; j++) {
					coord = coords[j];

					// convert longitude, latitude to x,y pixels
					point = fromLatLngToPoint(coord);
					setMin(point);

					points.push(point);
				}

				if (points.length) {
					geometries.push(points);
				}
			}
			
            			
			for (i = 0, l = geometries.length; i < l; i++) {
				points = geometries[i];

				for (j = 0, ll = points.length; j < ll; j++) {
					point = points[j];

					setMax(point);
				}
			}
            console.log(min);
            console.log(max);
		}

		function setMin(point) {
			min[0] = Math.min(min[0], point[0]);
			min[1] = Math.min(min[1], point[1]);
		}

		function setMax(point) {
			point[0] -= min[0];
			point[1] -= min[1];
			
			max[0] = Math.max(max[0], point[0]);
			max[1] = Math.max(max[1], point[1]);
		}

		function getScale() {
            console.log(Math.min(width / max[0], height / max[1]) * zoom)
          return Math.pow(2, parseInt(zoom));
		}

/*
        function zoomTo(location, scale) {
            var point = projection(location);
            return zoom
                .translate([width / 2 - point[0] * scale, height / 2 - point[1] * scale])
                .scale(scale);
            }
*/
		function getCenter(scale) {

			// todo: translate center with focus point
			var center = [
				(width - (scale * max[0])) / 2,
				(height - (scale * max[1])) / 2
			];

			center[0] += panX;
			center[1] += panY;

  			return center;
		}

		function drawPolygons() {
			var startDraw = new Date();
            
			drawing = true;

			var scale = getScale();	
            console.log(scale);

			// center image
			var center = getCenter(scale);
            
            //var llc = fromPointToLatLng({ x : ((scale * max[0])/2), y : ((scale * max[1])/2)});
            console.log(center);
            
            ctx.beginPath();
			ctx.arc(center[0]+((scale * max[0])/2), center[1] + ((scale * max[1])/2), 7, 0, 2 * Math.PI, false);
            ctx.fillStyle = 'red';
            ctx.fill();
            //ctx.lineWidth = 5;
            ctx.strokeStyle = '#003300';
            ctx.stroke();
			ctx.closePath();
            
			var points, point, pointx, pointy, polygons;

			// draw each polygon
			for (var i = 0, l = geometries.length; i < l; i++) {
				points = geometries[i];

				polygons = [];

				for (var j = 0, ll = points.length; j < ll; j++) {
					point = points[j];

					pointx = (center[0] + (point[0] * scale));
					pointy = (center[1] + (point[1] * scale));

					polygons.push([pointx, pointy]);
				}

				if (polygons.length) {
					draw(polygons);
				}
			}

			drawing = false;
            
            console.log("Time of draw geometries: " + new Date().setTime(new Date().getTime() - startDraw.getTime()) + " ms ");
		}
				
		function render() {

			ctx.clearRect(0, 0, width, height);

            var startLoad = new Date();
			$.getJSON(url).done(function(data) {
                console.log("Time of load geojson: " + new Date().setTime(new Date().getTime() - startLoad.getTime()) + " ms "); 
                
                var startParse = new Date();
				var geojsons = data.rows.map(function(row) {
					return JSON.parse(row.features);
				});

				extractGeometries(geojsons);
                console.log("Time of parse data: " + new Date().setTime(new Date().getTime() - startParse.getTime()) + " ms ");
                                
				drawPolygons();                
                
			}, this);

		}

		function draw(polygons) {
			
			ctx.beginPath();

			var data, i, l;

			data = polygons[0];
			ctx.moveTo(data[0], data[1]);

			for (i = 1, l = polygons.length; i < l; i++) {
				data = polygons[i];

				ctx.lineTo(data[0], data[1]);
					
			}

			ctx.stroke();
			ctx.closePath();
			
		}

		function handleScroll(ev){
			ev.preventDefault();
			ev.stopPropagation();

			var delta = ev.wheelDelta ? ev.wheelDelta / 60 : ev.detail ? -ev.detail : 0;

			if (delta){
				focus = [ev.offsetX, ev.offsetY];

				scaleTo(delta);
			}
		}

		function scaleTo(scale) {			
			zoom += scale;

			if (zoom < 9){ zoom = 9; return false; }

			if (!drawing){
				ctx.clearRect(0, 0, width, height);
				drawPolygons();
			}
		}

		function handleMouseDown(ev) {
			dragged = true;

			startCoords = [
				ev.offsetX - last[0],
				ev.offsetY - last[1]
			];
		}

		function handleMouseUp(ev) {
			dragged = false;
			
			last = [
				ev.offsetX - startCoords[0],
				ev.offsetY - startCoords[1]
			];
		}
		
		function handleMouseMove(ev) {
			if (!dragged) return;

			panX = ev.offsetX - startCoords[0];
			panY = ev.offsetY - startCoords[1];

			if (!drawing) {
				ctx.clearRect(0, 0, width, height);
				drawPolygons();
			}
		}


	})(jQuery);


 	</script>
</body>
</html>